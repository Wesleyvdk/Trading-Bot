// Database module for price data collection using Bun's native PostgreSQL support
import { SQL } from "bun";

let db: SQL | null = null;

/**
 * Initialize database connection
 */
export function getDb(): SQL {
    if (!db) {
        const databaseUrl = process.env.DATABASE_URL;
        if (!databaseUrl) {
            throw new Error("DATABASE_URL environment variable is required");
        }
        db = new SQL(databaseUrl);
        console.log("✅ Database connection initialized");
    }
    return db;
}

/**
 * Initialize the data collection tables
 */
export async function initDataTables(): Promise<void> {
    const sql = getDb();

    // BTC price ticks - high frequency price data from Binance
    await sql`
        CREATE TABLE IF NOT EXISTS btc_price_ticks (
            id BIGSERIAL PRIMARY KEY,
            price DECIMAL(18, 8) NOT NULL,
            timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            source VARCHAR(20) DEFAULT 'binance'
        )
    `;

    // Create index for fast time-based queries
    await sql`
        CREATE INDEX IF NOT EXISTS idx_btc_price_ticks_timestamp
        ON btc_price_ticks (timestamp DESC)
    `;

    // Market windows - tracks each 15-min or hourly market window
    await sql`
        CREATE TABLE IF NOT EXISTS market_windows (
            id BIGSERIAL PRIMARY KEY,
            market_type VARCHAR(10) NOT NULL,  -- '15-MIN' or '60-MIN'
            asset VARCHAR(10) NOT NULL,         -- 'BTC', 'ETH', 'SOL'
            window_start TIMESTAMPTZ NOT NULL,
            window_end TIMESTAMPTZ NOT NULL,
            strike_price DECIMAL(18, 8),
            outcome VARCHAR(10),                -- 'UP', 'DOWN', or NULL if not resolved
            condition_id VARCHAR(100),
            created_at TIMESTAMPTZ DEFAULT NOW(),
            UNIQUE(market_type, asset, window_start)
        )
    `;

    // Share price snapshots - Polymarket share prices during each window
    await sql`
        CREATE TABLE IF NOT EXISTS share_price_snapshots (
            id BIGSERIAL PRIMARY KEY,
            window_id BIGINT REFERENCES market_windows(id),
            up_bid DECIMAL(10, 6),
            up_ask DECIMAL(10, 6),
            down_bid DECIMAL(10, 6),
            down_ask DECIMAL(10, 6),
            minutes_elapsed INT NOT NULL,       -- Minutes since window start (0-14 or 0-59)
            timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW()
        )
    `;

    // Create index for fast window lookups
    await sql`
        CREATE INDEX IF NOT EXISTS idx_share_price_window
        ON share_price_snapshots (window_id, minutes_elapsed)
    `;

    // Pattern statistics - aggregated analysis results
    await sql`
        CREATE TABLE IF NOT EXISTS pattern_stats (
            id BIGSERIAL PRIMARY KEY,
            market_type VARCHAR(10) NOT NULL,
            pattern_name VARCHAR(100) NOT NULL,
            minute_bucket INT,                  -- Time bucket within window
            sample_count INT NOT NULL,
            win_rate DECIMAL(5, 4),             -- 0.0000 to 1.0000
            avg_profit DECIMAL(10, 4),
            reversal_probability DECIMAL(5, 4),
            metadata JSONB,
            calculated_at TIMESTAMPTZ DEFAULT NOW(),
            UNIQUE(market_type, pattern_name, minute_bucket)
        )
    `;

    // Trading signals generated by analysis
    await sql`
        CREATE TABLE IF NOT EXISTS trading_signals (
            id BIGSERIAL PRIMARY KEY,
            window_id BIGINT REFERENCES market_windows(id),
            signal_type VARCHAR(20) NOT NULL,   -- 'ENTRY', 'EXIT', 'FLIP', 'HOLD'
            direction VARCHAR(10),              -- 'UP' or 'DOWN'
            confidence DECIMAL(5, 4),           -- 0.0000 to 1.0000
            reason TEXT,
            btc_price DECIMAL(18, 8),
            share_price DECIMAL(10, 6),
            minutes_remaining INT,
            created_at TIMESTAMPTZ DEFAULT NOW()
        )
    `;

    // Strategy trades - tracks individual trades for both strategies
    await sql`
        CREATE TABLE IF NOT EXISTS strategy_trades (
            id BIGSERIAL PRIMARY KEY,
            strategy VARCHAR(20) NOT NULL,       -- 'momentum' or 'latency'
            market_type VARCHAR(10) NOT NULL,    -- '15-MIN' or '60-MIN'
            asset VARCHAR(10) NOT NULL,          -- 'BTC', 'ETH', 'SOL'
            direction VARCHAR(10) NOT NULL,      -- 'UP' or 'DOWN'
            entry_price DECIMAL(10, 6) NOT NULL, -- Share price paid
            entry_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            exit_price DECIMAL(10, 6),           -- Share price on exit (null if open)
            exit_time TIMESTAMPTZ,
            expected_edge DECIMAL(10, 6),        -- Edge at time of trade
            realized_pnl DECIMAL(12, 4),         -- Actual P&L
            outcome VARCHAR(10),                 -- 'WIN', 'LOSS', 'PENDING'
            trade_size_usd DECIMAL(10, 4) NOT NULL,
            condition_id VARCHAR(100),
            metadata JSONB
        )
    `;

    // Create index for strategy queries
    await sql`
        CREATE INDEX IF NOT EXISTS idx_strategy_trades_strategy
        ON strategy_trades (strategy, entry_time DESC)
    `;

    // Strategy performance - daily rollup for dashboard
    await sql`
        CREATE TABLE IF NOT EXISTS strategy_performance (
            id BIGSERIAL PRIMARY KEY,
            strategy VARCHAR(20) NOT NULL,
            date DATE NOT NULL,
            total_trades INT DEFAULT 0,
            winning_trades INT DEFAULT 0,
            losing_trades INT DEFAULT 0,
            total_pnl DECIMAL(12, 4) DEFAULT 0,
            avg_edge DECIMAL(10, 6),
            win_rate DECIMAL(5, 4),
            max_drawdown DECIMAL(10, 4),
            UNIQUE(strategy, date)
        )
    `;

    // Strategy logs - high frequency strategy state tracking
    await sql`
        CREATE TABLE IF NOT EXISTS strategy_logs (
            id BIGSERIAL PRIMARY KEY,
            tick_number INT NOT NULL,
            price DECIMAL(18, 8) NOT NULL,
            momentum_60 DECIMAL(10, 6),
            momentum_15 DECIMAL(10, 6),
            open_positions INT DEFAULT 0,
            created_at TIMESTAMPTZ DEFAULT NOW()
        )
    `;

    // Ensure created_at exists (in case table existed without it)
    await sql`
        ALTER TABLE strategy_logs 
        ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ DEFAULT NOW()
    `;

    // Create index for time-based queries
    await sql`
        CREATE INDEX IF NOT EXISTS idx_strategy_logs_created_at
        ON strategy_logs (created_at DESC)
    `;

    // Latency logs - evaluations from latency arbitrage bot
    await sql`
        CREATE TABLE IF NOT EXISTS latency_logs (
            id BIGSERIAL PRIMARY KEY,
            asset VARCHAR(10) NOT NULL,
            market_type VARCHAR(10) NOT NULL,
            time_remaining INT NOT NULL,
            price DECIMAL(18, 8) NOT NULL,
            strike DECIMAL(18, 8) NOT NULL,
            delta_percent DECIMAL(10, 4),
            true_prob_up DECIMAL(6, 4),
            market_prob_up DECIMAL(6, 4),
            edge_up DECIMAL(6, 4),
            reason TEXT,
            created_at TIMESTAMPTZ DEFAULT NOW()
        )
    `;

    // Create index for latency logs
    await sql`
        CREATE INDEX IF NOT EXISTS idx_latency_logs_created_at
        ON latency_logs (created_at DESC)
    `;

    console.log("✅ Data collection tables initialized");
}

// ============ INSERT FUNCTIONS ============

/**
 * Insert a BTC price tick
 */
export async function insertBtcPriceTick(price: number, timestamp?: Date): Promise<void> {
    const sql = getDb();
    const ts = timestamp || new Date();
    await sql`
        INSERT INTO btc_price_ticks (price, timestamp)
        VALUES (${price}, ${ts})
    `;
}

/**
 * Insert or get a market window
 */
export async function upsertMarketWindow(
    marketType: string,
    asset: string,
    windowStart: Date,
    windowEnd: Date,
    strikePrice: number | null,
    conditionId?: string
): Promise<number> {
    const sql = getDb();

    const result = await sql`
        INSERT INTO market_windows (market_type, asset, window_start, window_end, strike_price, condition_id)
        VALUES (${marketType}, ${asset}, ${windowStart}, ${windowEnd}, ${strikePrice}, ${conditionId || null})
        ON CONFLICT (market_type, asset, window_start)
        DO UPDATE SET
            strike_price = COALESCE(EXCLUDED.strike_price, market_windows.strike_price),
            condition_id = COALESCE(EXCLUDED.condition_id, market_windows.condition_id)
        RETURNING id
    `;

    return result[0].id;
}

/**
 * Update market window outcome
 */
export async function updateMarketOutcome(windowId: number, outcome: string): Promise<void> {
    const sql = getDb();
    await sql`
        UPDATE market_windows
        SET outcome = ${outcome}
        WHERE id = ${windowId}
    `;
}

/**
 * Insert a share price snapshot
 */
export async function insertSharePriceSnapshot(
    windowId: number,
    upBid: number,
    upAsk: number,
    downBid: number,
    downAsk: number,
    minutesElapsed: number
): Promise<void> {
    const sql = getDb();
    await sql`
        INSERT INTO share_price_snapshots (window_id, up_bid, up_ask, down_bid, down_ask, minutes_elapsed)
        VALUES (${windowId}, ${upBid}, ${upAsk}, ${downBid}, ${downAsk}, ${minutesElapsed})
    `;
}

/**
 * Insert a trading signal
 */
export async function insertTradingSignal(
    windowId: number,
    signalType: string,
    direction: string | null,
    confidence: number,
    reason: string,
    btcPrice: number,
    sharePrice: number,
    minutesRemaining: number
): Promise<void> {
    const sql = getDb();
    await sql`
        INSERT INTO trading_signals (window_id, signal_type, direction, confidence, reason, btc_price, share_price, minutes_remaining)
        VALUES (${windowId}, ${signalType}, ${direction}, ${confidence}, ${reason}, ${btcPrice}, ${sharePrice}, ${minutesRemaining})
    `;
}

/**
 * Insert a strategy trade
 */
export interface StrategyTradeInput {
    strategy: string;
    marketType: string;
    asset: string;
    direction: string;
    entryPrice: number;
    expectedEdge: number;
    tradeSizeUsd: number;
    conditionId?: string;
    metadata?: object;
}

export async function insertStrategyTrade(trade: StrategyTradeInput): Promise<number> {
    const sql = getDb();

    const result = await sql`
        INSERT INTO strategy_trades (
            strategy, market_type, asset, direction, entry_price, 
            expected_edge, trade_size_usd, condition_id, metadata, outcome
        )
        VALUES (
            ${trade.strategy}, ${trade.marketType}, ${trade.asset}, ${trade.direction},
            ${trade.entryPrice}, ${trade.expectedEdge}, ${trade.tradeSizeUsd},
            ${trade.conditionId || null}, ${JSON.stringify(trade.metadata || {})}, 'PENDING'
        )
        RETURNING id
    `;

    return result[0].id;
}

/**
 * Update trade outcome after market resolution
 */
export async function updateTradeOutcome(
    tradeId: number,
    exitPrice: number,
    realizedPnl: number,
    outcome: string
): Promise<void> {
    const sql = getDb();
    await sql`
        UPDATE strategy_trades
        SET exit_price = ${exitPrice},
            exit_time = NOW(),
            realized_pnl = ${realizedPnl},
            outcome = ${outcome}
        WHERE id = ${tradeId}
    `;
}

/**
 * Insert a strategy log entry (heartbeat/state)
 */
export async function insertStrategyLog(
    tickNumber: number,
    price: number,
    momentum60: number | null,
    momentum15: number | null,
    openPositions: number
): Promise<void> {
    const sql = getDb();
    await sql`
        INSERT INTO strategy_logs (tick_number, price, momentum_60, momentum_15, open_positions)
        VALUES (${tickNumber}, ${price}, ${momentum60}, ${momentum15}, ${openPositions})
    `;
}

/**
 * Insert a latency evaluation log
 */
export async function insertLatencyLog(
    asset: string,
    marketType: string,
    timeRemaining: number,
    price: number,
    strike: number,
    deltaPercent: number,
    trueProbUp: number,
    marketProbUp: number,
    edgeUp: number,
    reason: string
): Promise<void> {
    const sql = getDb();
    await sql`
        INSERT INTO latency_logs (
            asset, market_type, time_remaining, price, strike, 
            delta_percent, true_prob_up, market_prob_up, edge_up, reason
        )
        VALUES (
            ${asset}, ${marketType}, ${timeRemaining}, ${price}, ${strike},
            ${deltaPercent}, ${trueProbUp}, ${marketProbUp}, ${edgeUp}, ${reason}
        )
    `;
}

/**
 * Get daily performance for a strategy
 */
export async function getDailyPerformance(strategy: string, days: number = 7): Promise<Array<{
    date: Date;
    trades: number;
    wins: number;
    losses: number;
    pnl: number;
    winRate: number;
}>> {
    const sql = getDb();

    const result = await sql`
        SELECT 
            DATE(entry_time) as date,
            COUNT(*) as trades,
            SUM(CASE WHEN outcome = 'WIN' THEN 1 ELSE 0 END) as wins,
            SUM(CASE WHEN outcome = 'LOSS' THEN 1 ELSE 0 END) as losses,
            SUM(COALESCE(realized_pnl, 0)) as pnl
        FROM strategy_trades
        WHERE strategy = ${strategy}
          AND entry_time > NOW() - INTERVAL '1 day' * ${days}
        GROUP BY DATE(entry_time)
        ORDER BY date DESC
    `;

    return result.map((row: any) => ({
        date: new Date(row.date),
        trades: parseInt(row.trades),
        wins: parseInt(row.wins),
        losses: parseInt(row.losses),
        pnl: parseFloat(row.pnl),
        winRate: parseInt(row.wins) / parseInt(row.trades)
    }));
}

/**
 * Get strategy comparison stats
 */
export async function getStrategyComparison(days: number = 7): Promise<{
    momentum: { trades: number; wins: number; pnl: number; winRate: number };
    latency: { trades: number; wins: number; pnl: number; winRate: number };
}> {
    const sql = getDb();

    const result = await sql`
        SELECT 
            strategy,
            COUNT(*) as trades,
            SUM(CASE WHEN outcome = 'WIN' THEN 1 ELSE 0 END) as wins,
            SUM(COALESCE(realized_pnl, 0)) as pnl
        FROM strategy_trades
        WHERE entry_time > NOW() - INTERVAL '1 day' * ${days}
          AND outcome IS NOT NULL
        GROUP BY strategy
    `;

    const empty = { trades: 0, wins: 0, pnl: 0, winRate: 0 };
    const stats: any = { momentum: { ...empty }, latency: { ...empty } };

    for (const row of result) {
        const key = row.strategy as keyof typeof stats;
        if (stats[key]) {
            stats[key] = {
                trades: parseInt(row.trades),
                wins: parseInt(row.wins),
                pnl: parseFloat(row.pnl),
                winRate: parseInt(row.wins) / parseInt(row.trades)
            };
        }
    }

    return stats;
}

/**
 * Get recent trades for a strategy
 */
export async function getRecentTrades(strategy: string, limit: number = 50): Promise<Array<{
    id: number;
    asset: string;
    marketType: string;
    direction: string;
    entryPrice: number;
    exitPrice: number | null;
    expectedEdge: number;
    realizedPnl: number | null;
    outcome: string;
    entryTime: Date;
}>> {
    const sql = getDb();

    const result = await sql`
        SELECT id, asset, market_type, direction, entry_price, exit_price,
               expected_edge, realized_pnl, outcome, entry_time
        FROM strategy_trades
        WHERE strategy = ${strategy}
        ORDER BY entry_time DESC
        LIMIT ${limit}
    `;

    return result.map((row: any) => ({
        id: row.id,
        asset: row.asset,
        marketType: row.market_type,
        direction: row.direction,
        entryPrice: parseFloat(row.entry_price),
        exitPrice: row.exit_price ? parseFloat(row.exit_price) : null,
        expectedEdge: parseFloat(row.expected_edge || 0),
        realizedPnl: row.realized_pnl ? parseFloat(row.realized_pnl) : null,
        outcome: row.outcome,
        entryTime: new Date(row.entry_time)
    }));
}

// ============ QUERY FUNCTIONS ============

/**
 * Get BTC price history for a time range
 */
export async function getBtcPriceHistory(
    startTime: Date,
    endTime: Date,
    intervalSeconds: number = 5
): Promise<Array<{ price: number; timestamp: Date }>> {
    const sql = getDb();

    // Use time bucketing to reduce data points
    const result = await sql`
        SELECT
            AVG(price)::DECIMAL(18,8) as price,
            date_trunc('second', timestamp) -
                (EXTRACT(SECOND FROM timestamp)::INT % ${intervalSeconds}) * INTERVAL '1 second' as timestamp
        FROM btc_price_ticks
        WHERE timestamp BETWEEN ${startTime} AND ${endTime}
        GROUP BY 2
        ORDER BY timestamp ASC
    `;

    return result.map(row => ({
        price: parseFloat(row.price),
        timestamp: new Date(row.timestamp)
    }));
}

/**
 * Get completed market windows for analysis
 */
export async function getCompletedWindows(
    marketType: string,
    days: number = 7
): Promise<Array<{
    id: number;
    asset: string;
    window_start: Date;
    window_end: Date;
    strike_price: number;
    outcome: string;
}>> {
    const sql = getDb();

    const result = await sql`
        SELECT id, asset, window_start, window_end, strike_price, outcome
        FROM market_windows
        WHERE market_type = ${marketType}
          AND outcome IS NOT NULL
          AND window_end > NOW() - INTERVAL '${days} days'
        ORDER BY window_start DESC
    `;

    return result.map(row => ({
        id: row.id,
        asset: row.asset,
        window_start: new Date(row.window_start),
        window_end: new Date(row.window_end),
        strike_price: parseFloat(row.strike_price),
        outcome: row.outcome
    }));
}

/**
 * Get share price history for a window
 */
export async function getWindowSharePrices(windowId: number): Promise<Array<{
    minutes_elapsed: number;
    up_bid: number;
    up_ask: number;
    down_bid: number;
    down_ask: number;
    timestamp: Date;
}>> {
    const sql = getDb();

    const result = await sql`
        SELECT minutes_elapsed, up_bid, up_ask, down_bid, down_ask, timestamp
        FROM share_price_snapshots
        WHERE window_id = ${windowId}
        ORDER BY minutes_elapsed ASC
    `;

    return result.map(row => ({
        minutes_elapsed: row.minutes_elapsed,
        up_bid: parseFloat(row.up_bid),
        up_ask: parseFloat(row.up_ask),
        down_bid: parseFloat(row.down_bid),
        down_ask: parseFloat(row.down_ask),
        timestamp: new Date(row.timestamp)
    }));
}

/**
 * Get pattern statistics
 */
export async function getPatternStats(marketType: string): Promise<Array<{
    pattern_name: string;
    minute_bucket: number;
    sample_count: number;
    win_rate: number;
    reversal_probability: number;
}>> {
    const sql = getDb();

    const result = await sql`
        SELECT pattern_name, minute_bucket, sample_count, win_rate, reversal_probability
        FROM pattern_stats
        WHERE market_type = ${marketType}
        ORDER BY pattern_name, minute_bucket
    `;

    return result.map(row => ({
        pattern_name: row.pattern_name,
        minute_bucket: row.minute_bucket,
        sample_count: row.sample_count,
        win_rate: parseFloat(row.win_rate),
        reversal_probability: parseFloat(row.reversal_probability)
    }));
}

/**
 * Upsert pattern statistics
 */
export async function upsertPatternStats(
    marketType: string,
    patternName: string,
    minuteBucket: number | null,
    sampleCount: number,
    winRate: number,
    reversalProbability: number,
    metadata?: object
): Promise<void> {
    const sql = getDb();

    await sql`
        INSERT INTO pattern_stats (market_type, pattern_name, minute_bucket, sample_count, win_rate, reversal_probability, metadata, calculated_at)
        VALUES (${marketType}, ${patternName}, ${minuteBucket}, ${sampleCount}, ${winRate}, ${reversalProbability}, ${JSON.stringify(metadata || {})}, NOW())
        ON CONFLICT (market_type, pattern_name, minute_bucket)
        DO UPDATE SET
            sample_count = EXCLUDED.sample_count,
            win_rate = EXCLUDED.win_rate,
            reversal_probability = EXCLUDED.reversal_probability,
            metadata = EXCLUDED.metadata,
            calculated_at = NOW()
    `;
}

/**
 * Get data collection stats
 */
export async function getCollectionStats(): Promise<{
    btc_ticks: number;
    market_windows: number;
    completed_windows: number;
    share_snapshots: number;
    oldest_data: Date | null;
    newest_data: Date | null;
}> {
    const sql = getDb();

    const [btcCount] = await sql`SELECT COUNT(*) as count FROM btc_price_ticks`;
    const [windowCount] = await sql`SELECT COUNT(*) as count FROM market_windows`;
    const [completedCount] = await sql`SELECT COUNT(*) as count FROM market_windows WHERE outcome IS NOT NULL`;
    const [snapshotCount] = await sql`SELECT COUNT(*) as count FROM share_price_snapshots`;
    const [oldest] = await sql`SELECT MIN(timestamp) as ts FROM btc_price_ticks`;
    const [newest] = await sql`SELECT MAX(timestamp) as ts FROM btc_price_ticks`;

    return {
        btc_ticks: parseInt(btcCount.count),
        market_windows: parseInt(windowCount.count),
        completed_windows: parseInt(completedCount.count),
        share_snapshots: parseInt(snapshotCount.count),
        oldest_data: oldest.ts ? new Date(oldest.ts) : null,
        newest_data: newest.ts ? new Date(newest.ts) : null
    };
}

/**
 * Clean up old data (keep last N days)
 */
export async function cleanupOldData(keepDays: number = 14): Promise<{
    deleted_ticks: number;
    deleted_windows: number;
}> {
    const sql = getDb();

    const [ticksResult] = await sql`
        WITH deleted AS (
            DELETE FROM btc_price_ticks
            WHERE timestamp < NOW() - INTERVAL '${keepDays} days'
            RETURNING 1
        )
        SELECT COUNT(*) as count FROM deleted
    `;

    const [windowsResult] = await sql`
        WITH deleted AS (
            DELETE FROM market_windows
            WHERE window_end < NOW() - INTERVAL '${keepDays} days'
            RETURNING 1
        )
        SELECT COUNT(*) as count FROM deleted
    `;

    return {
        deleted_ticks: parseInt(ticksResult.count),
        deleted_windows: parseInt(windowsResult.count)
    };
}
